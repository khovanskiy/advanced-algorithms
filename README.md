External memory: k-way merge sort
====================

> Хованский Виктор Сергеевич, M4136c

Задача состоит в том, чтобы отсортировать большой файл, который не умещается целиком в оперативной памяти.

------
## Условия
Пусть исходный файл *INPUT* занимает **T** байт на жестком диске.
Нужно его отсортировать, используя **M** байт в оперативной памяти.
Результат должен быть записан в файл *OUTPUT*.

-------

## Описание алгоритма
В первой фазе алгоритма будем считывать блоки размера **M** в оперативную память и сортировать их. Далее после сдвига указателя в файле на позицию **qM**, где **q** - номер блока. Можно записать отсортированный блок в файл.

Во второй фазе алгоритма заведем в памяти **k=[T/M]** ленивых узлов, каждый из которых будет хранить следующие поля:

 - Локальный индекс в буфере *bufferIndex*;
 - Доступная длина буфера *bufferAvailable*;
 - Глобальный индекс в блоке *blockIndex*;
 - Доступная длина блока *blockAvailable*;

Каждый узел представим в виде итератора. Тогда условием обновления данных в буфере будет:

```
if (bufferIndex == bufferAvailable && blockIndex < blockAvailable) { /**/ }
```

И при истинности данного выражения нужно загрузить в буфер данные с позиции

```
q * blockSize + blockIndex
```

Данные в блоке были отсортированы в первой фазе алгоритма, поэтому на позиции *bufferIndex* будет всегда наименьший элемент (считаем, что сортировка по возрастанию) в блоке.

Далее заводим приоритетную очередь из узлов, где приоритетом будет выступать наименьший элемент из блока узла. Теперь же можно последовательно извлекать узлы-итераторы из очереди и записывать очередной элемент итератора в выходной файл *OUTPUT*. Если после записи очередного элемента в файл, итератор не пуст, то добавляем его обратно в очередь. Так продолжается до тех пор, пока очередь не станет пустой.

-------

## Тестирование
Для тестирования используется генерация случайного равновероятного набора элементов, которые записываются в массив.

Далее данный массив записывается в файл *INPUT* и сортируется в оперативной памяти для сравнения.

После этого сортируется файл *INPUT*, описанным выше алгоритмом, и проверяется корректность сортировки.
